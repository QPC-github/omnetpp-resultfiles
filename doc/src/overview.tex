\begin{abstract} This document describes the format of result files
generated by the OMNeT++ simulation engine. The format is thought to be of
interest outside the OMNeT++ community as well, because it is open,
general, and extensible, and there are open-source libraries and tools for
both generating and processing files in this format. These characteristics
make it feasible for other simulators to adopt this format as their native
result file format. \end{abstract}

\section{Overview}

This document describes the format of result files generated by the OMNeT++
simulation engine, and understood by result processing tools.

The file format is general in the sense that it does not contain General:

database-like infrastructure can be built on it

types of results

assumptions about the model

Open: the file format is open in both the legal meaning (free of legal
constraints), and it is accessible, because it is a line-oriented text
file.

Extensible:

Performance (indexing)

\subsection{Concepts}

The file format assumes that simulation results are generated during
\textit{simulation runs}, and assigns a unique \textit{run ID} to each run.
Run IDs are recorded into the result files. It is possible to use generated
globally unique identifiers (GUIDs) as run IDs, but we recommend
concatenating them from a number of human-readable fields like the network
name, experiment or measurement name, the hostname, a high-resolution timestamp, etc.
This makes the ID meaningful while still reasonably unique and compact.

The simulation model assumed to be composed of \textit{components} (OMNeT++
uses the term \textit{module}), and that every result item belongs to some
component. Global statistics are regarded as belonging to the ``root''
component. Components and result items have names; a result item can be
uniquely identified by the simulation run that generated it, the name of
the component, and the name of the result itself. Component names will be
usually (but not necessarily) hierarchical; the recommended separator
between component path segments is a dot.

The result file formats defines two kinds of results: \textit{output
vectors} and \textit{output scalars}. Output vectors are basically
timestamped numeric data, used to record the history of one particular
simulation run. Output scalars are summary data, usually written out at the
end of the simulation. Scalars can be simply numeric values, or can be some
statistical summary composed of several numbers (mean, count, standard deviation,
minimum, maximum, histogram data, etc).

Every simulation result can be annotated with metadata. Metadata
annotations are called attributes; two examples for attributes are
measurement unit (e.g. mW), and interpolation mode hint for plotting
(e.g. linear, sample-hold, etc.) for vector results.

In addition to results, the file format defines the way to record
further data such as the name of the simulation model, its parameters, the
random number seeds, various simulator configuration settings and so on.
The intent is to record enough information so that the user can later
reproduce the results. Three special-purpose run attributes,
\textit{experiment}, \textit{measurement} and \textit{replication},
are related to organizing parameter studies.


\subsection{Libraries and Tools}

Several open-source tools and libraries are available for generating and
processing result files in the OMNeT++ format.

First of all, the OMNeT++ Simulation IDE provides an \textit{Analysis
Tool}. The Analysis Tool is also available as a standalone tool as a
separate download (``Scave''). The Analysis Tool lets the user specify
result files (or a set of result files using wildcards), and presents their
contents in a database-like manner. One can browse the results, select
subsets data (scalars, vectors, histograms) that are of interest, apply
processing steps, and create various charts or plots from them. These steps
can be grouped into and stored as "recipes", which get automatically
re-applied when new result files are added or existing files are replaced.
This automation saves the user a lot of repetitive work, without resorting
to scripting.

Much of the IDE Analysis Tool's functionality is available on the command
line as well, via the \ttt{scavetool} program. \ttt{scavetool} is suitable
for filtering and basic processing of result files, and exporting the
result in various formats (e.g. CSV, Matlab, Octave). \ttt{scavetool} has
no graphics capabilities, but it can produce files that can be plotted with
other tools like gnuplot. \ttt{scavetool} and its internal class library
have been released under the BSD license as well, which makes it open for
improvement by other parties, and allows its engine to be used as part of
other (GUI or command-line) programs.

Given that the file format is simple and straightforward, many users have
created their own one-shot result processing scripts in Perl, Python, Ruby,
awk and other languages.

For more sophisticated processing, the \textit{OMNeT++ R extension package}
makes the functionality of scavetool and more available in GNU R
(r-project.org). The package supports reading, processing and easy plotting
of result files, adding to the vast arsenal of statistical computing and
graphical capabilities of R.

At the time of writing, ns-3 has support for creating scalar files in this
format (vector file writing has not been implemented). Java-based
simulators can directly use the \textit{jresultwriter} library. The
\textit{jresultwriter} package comes with a working simulation example (a
minimal simulation framework with the classic Aloha simulation on top of
it) that shows how to integrate the result recording library into a
simulation framework. A C++ version of the this package is under
development. \ttt{scavetool} can also save the result of filtering and/or
processing steps in the same result file format.

Due to the simplicity of the file format, it is also straighforward to
write your own code. The only tricky part is generating indices for output
vector files; however, it is not crucial to implement it, because indices
can also be generated in a post-processing step, using a built-in function
of \ttt{scavetool}.


\subsection{File Format Overview}
% move before the Tools & Libs part?

Result files are textual, line-oriented files. The advantage of a
text-based format is that it is very accessible with a wide range of tools
and languages. Scalars and vectors are recorded into separate files
for practical reasons: vector data typically consume several magnitudes
more disk space than scalars.

\textbf{File Header.}
Result files start with a header that contains several attributes of the
simulation run: the run ID, the network name (in OMNeT++, the NED type
name), the experiment-measurement-replication labels, the values of
iteration variables and the repetition counter, the date and time, the host
name, the process id of the simulation, random number seeds, configuration
options, and so on. These data can be useful during result processing, and
increase the reproducibility of the results.

The following example result file header shows the run ID (in the \ttt{run}
line) and various recorded run attributes:

\begin{verbatim}
version 2
run PureAlohaExperiment-3-20100616-11:33:22-5568
attr network Aloha
attr datetime 20100616-11:33:22
attr processid 5568
attr configname PureAlohaExperiment
attr runnumber 3
attr experiment PureAlohaExperiment
attr measurement "$numHosts=10, $mean=2"
attr replication #1
attr iterationvars "$numHosts=10, $mean=2"
attr iterationvars2 "$numHosts=10, $mean=2, $repetition=1"
attr seedset 3
...
\end{verbatim}


\textbf{Output Vectors.}
All output vectors from a simulation run are recorded into a common file.
There two types of lines: vector declaration lines (beginning with the word
\ttt{vector}), and data lines. A \textit{vector declaration line}
introduces a new output vector, and its columns are: vector Id, module of
creation, vector name, and multiplicity (usually 1).
Actual data recorded in this vector are on \textit{data lines} which begin
with the vector Id. Further columns on data lines are the simulation time
and the recorded value.

An example file fragment:

\begin{verbatim}
...
vector 1   net.host[12]  responseTime  TV
attr unit s
attr interpolationmode none
1  12.895  2355.66
1  14.126  4577.66664666
vector 2   net.router[9].ppp[0] queueLength  TV
attr interpolationmode sample-hold
2  16.960  2
1  23.086  2355.66666666
2  24.026  8
...
\end{verbatim}

For efficient random access, ...TODO

Vector data are recorded into the file clustered by
output vectors, which, combined with index files, allows much more
efficient processing. Using the index file, tools can extract particular
vectors by reading only those parts of the file where the desired data are
located, and do not need to scan through the whole file linearly.


\textbf{Output Scalars}.
Fragment of an output scalar file (without header):

\begin{verbatim}
...
scalar "lan.hostA.mac" "frames sent"  99
scalar "lan.hostA.mac" "frames rcvd"  3088
scalar "lan.hostA.mac" "bytes sent"   64869
scalar "lan.hostA.mac" "bytes rcvd"   3529448
...
\end{verbatim}

Every scalar generates one \ttt{scalar} line in the file.

Statistics objects generate several lines: mean, standard deviation, etc.

%% FIXME TODO attributes, statistics example, etc

