
\section{How to plot a vector?}

If \ttt{v} a matrix or data frame with \ttt{x} and \ttt{y} columns, you can draw a plot as:

\begin{verbatim}
> plotLineChart(list(v))
\end{verbatim}

\section{How to plot several vectors?}

If \ttt{v1}, \\ttt{v2}, \ttt{v3} are matrices or data frames with \ttt{x} and \ttt{y} columns,
the plot containing the 3 lines can be generated by:

\begin{verbatim}
> plotLineChart(list(a=v1, b=v2, c=v3))
\end{verbatim}

The lines are named \ttt{'a'}, \ttt{'b'} and \ttt{'c'}, these names can be used to specify
properties of the lines:

\begin{verbatim}
> plotLineChart(list(a=v1, b=v2, c=v3), 'Line.Color/a'='red', 'Symbols.Type/b'='Square', 'Line.Type/c'='SampleHold')
\end{verbatim}

These line names are displayed on the legend too:

\begin{verbatim}
> plotLineChart(list(a=v1, b=v2, c=v3), Legend.Display='true')
\end{verbatim}

If you want to generate a plot from vectors in a dataset, use the \ttt{makeLineChartDataset()} to select
the vectors and give the lines sensible names:

\begin{verbatim}
> vs <- makeLineChartDataset(dataset, '{configname}/{runnumber} - {module} {name}')
> plotLineChart(vs, Legend.Display='true')
\end{verbatim}

\section{How to compute and plot a histogram of a vector?}

If \ttt{v} is a numeric vector, then the \ttt{hist()} function from the \ttt{graphics} package
can be used to generate a histogram object and draw a histograme plot.

\begin{verbatim}
> h <- hist(v)
\end{verbatim}

If you want to put several histogram on a single plot:

\begin{verbatim}
> h1 <- hist(v1, plot=FALSE)
> h2 <- hist(v2, plot=FALSE)
> plot(h1)
> plot(h2, add=TRUE)
\end{verbatim}

If \ttt{d} is a loaded dataset containing histogram data, then \ttt{makeHistograms()} can generate
histogram objects:

\begin{verbatim}
> hs <- makeHistograms(d, '{module} {name}') 
\end{verbatim}

The result is a list of histgram objects, the elements are identified by module and statistic name.

\section{How to plot a histogram together with its cumulative distribution function?}

\section{How to transform a dataset into another dataset where all scalars are averaged across replications?}

\begin{verbatim}
d <- averageScalarsAcrossReplications(dataset)
\end{verbatim}

\subsection{How to compute confidence intervals as well?}

\begin{verbatim}
d <- averageScalarsAcrossReplications(dataset, conf.level=0.95)
\end{verbatim}

\section{How to create a bar chart of some scalars where error bars indicate confidence interval?}

\begin{verbatim}
heigths <- makeBarChartDataset(dataset, rows=c('measurement'), columns=c('name'))
conf.intervals <- makeBarChartDataset(dataset, rows=c('measurement'), columns=c('name'), conf.int(0.95) )
plotBarChart(heigths, list(Legend.Display='true', Legend.Anchoring='NorthWest'), conf.int=conf.intervals)
\end{verbatim}

\section{How to average some scalars across modules?}

For example, if you want the average of \ttt{'avgQueueLength'} across all queue modules:

\begin{verbatim}
ql <- subset(d$scalars, grepl('.*\\.queue', module) & name='avgQueueLength')
mean(ql$value)
\end{verbatim}

\section{How to compute the mean, stddev, min, max etc of vectors?}

If the vector is loaded into a dataset, then the \ttt{mean}, \ttt{sd}, \ttt{min}, \ttt{max}
functions can be used:

\begin{verbatim}
> d <- loadDataset('Aloha.vec', add('vector'))
> d <- loadVectors(d, NULL)
> vs <- split(d$vectordata$y, d$vectordata$resultkey)
> lapply(vs, mean)
> lapply(vs, sd)
> lapply(vs, min)
> lapply(vs, max)
> lapply(vs, summary)
\end{verbatim}

The current version does not support computing the summary statistics without loading the vectors,
but it is planned in a future version to do so.

\section{How to plot a scatter chart where the X axis is some run iteration
variable (i.e. \$numHosts)?}

Iteration variables are saved as scalars as well, so you can write:

\begin{verbatim}
d <- makeScatterChartDataset(dataset, xModule='.', xName='numHosts')
plotLineChart(d)
\end{verbatim}

\section{How to plot a 3D chart where the X,Y axes are run iteration variables?}

(i.e. \$numHosts, \$transmitPower)

persp

