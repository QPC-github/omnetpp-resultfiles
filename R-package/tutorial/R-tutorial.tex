\section{Getting Started}

This tutorial is for R newbies. Experienced R users may find that I am explaining some basic R stuff.

Installing the package:

\begin{verbatim}
$ R CMD INSTALL omnetpp_0.1-1.tar.gz
\end{verbatim}

Start R:

\begin{verbatim}
$ R
\end{verbatim}

Loading the OMNeT++ extension library:

\begin{verbatim}
> require(omnetpp)
\end{verbatim}

You'll get some messages about namespace conflicts; can be ignored. (The package defines 
symbols in the "omnetpp" namespace, and some have the same name as functions 
in the "base" namespace. The require() function automatically imports the contents 
of the omnetpp namespace into the global namespace, hence the conflict with the 
already imported "base" functions.)

Getting help:

\begin{verbatim}
> ?omnetpp
\end{verbatim}

displays a short description of the package, and hints that the

\begin{verbatim}
> library(help="omnetpp")
\end{verbatim}

command lists all commands contributed by this package:

\begin{verbatim}
> library(help="omnetpp")

                Information on package 'omnetpp'

Description:

Package:       omnetpp
Version:       0.1-1
<snip>

Index:

createBarChartDataset   Create a bar chart dataset from scalars
createHistograms        Build histogram objects from histogram bins.
createScatterChartDataset
                        Create an XY data from scalars.
filters                 Filters
loadDataset             Loads data from result files
loadVectors             Loads vector data from result files and applies
                        some processing
omnetpp-package         The OMNeT++ Package
patterns                Pattern language
plotBarChart            Plots a bar chart.
plotHistogramChart      Plot a histogram chart.
plotLineChart           Plots a line chart.
\end{verbatim}

You can also watch the demos:

\begin{verbatim}
> demo(dataset, package='omnetpp')
> demo(charts, package='omnetpp')
\end{verbatim}

For this tutorial, I gathered some OMNeT++ result files in the directory 
in the \ttt{rtut/} subdir of my home directory. Let us change first into that 
directory so that we can access the files without having to specify 
full path. This is possible by quitting R (\ttt{q()} command or Ctrl+D), 
changing into that directory at the shell prompt and restarting R, 
but it can also be done from within R:

\begin{verbatim}
> setwd("~/rtut")
> getwd()
[1] "/home/andras/rtut"
> list.files()
[1] "PureAlohaExperiment-0.sca" "PureAlohaExperiment-1.sca"
[3] "PureAlohaExperiment-2.sca"
\end{verbatim}

Now we load the contents of the files into an R data frame.

\begin{verbatim}
> x <- loadDataset("*.sca")
Loaded PureAlohaExperiment-0.sca
Loaded PureAlohaExperiment-1.sca
Loaded PureAlohaExperiment-2.sca
\end{verbatim}

Why does loadDataset() look so complicated?  TODO because it does much more: one can have more than one add(), and also discard(); within an add() one can filter by result type (scalar, vector, histogram), by result item name, etc.

You can print the contents of the data frame by simply typing the name of the variable:

\begin{verbatim}
> x
...
\end{verbatim}

The output is quite long. However, you can notice that the data frame contains several components:
"runs", "files", "scalars", etc. The list of all components can be displayed with the

\begin{verbatim}
> names(x)
[1] "runs"       "files"      "scalars"    "vectors"    "histograms"
[6] "fields"     "bins"       "params"     "attributes"
\end{verbatim}

command, and individual components can be printed with the \$ notation:

\begin{verbatim}
> x$files
  file_key directory                  filename                    ospath
1        0         . PureAlohaExperiment-0.sca PureAlohaExperiment-0.sca
2        1         . PureAlohaExperiment-1.sca PureAlohaExperiment-1.sca
3        2         . PureAlohaExperiment-2.sca PureAlohaExperiment-2.sca

> x$runs
  run_key                                         runid          experiment           measurement replication
1       0 PureAlohaExperiment-0-20100427-16:30:15-25274 PureAlohaExperiment $numHosts=10, $mean=1          #0
2       1 PureAlohaExperiment-1-20100427-16:30:16-25283 PureAlohaExperiment $numHosts=10, $mean=1          #1
3       2 PureAlohaExperiment-2-20100427-16:30:17-25289 PureAlohaExperiment $numHosts=10, $mean=2          #0

> x$scalars
   scalar_key run_key file_key       module                    name        value
1           0       0        0            .                    mean 1.000000e+00
2           1       0        0            .                numHosts 1.000000e+01
3           2       0        0 Aloha.server                duration 5.400007e+03
4           3       0        0 Aloha.server    collisionLength:mean 1.969656e-01
5           4       0        0 Aloha.server     collisionLength:sum 2.415980e+03
6           5       0        0 Aloha.server     collisionLength:max 8.734217e-01
...
\end{verbatim}

You may notice that this data structure looks like a relational database, where
files, runs and result items (scalars, vectors) are connected via keys. Indeed,
R makes it simple to "join" tables using the "key" columns; we'll show this later.

At this point, R's default display width of 80 characters may have resulted in wrapping
of the tables. Some R versions automatically adapt the display width to the width of the
terminal window, but if yours doesn't, you can increase the display width with the
following command:

\begin{verbatim}
> options(width=120)
\end{verbatim}

We won't need all components in the data frame (for example, we don't have vectors 
and histograms in the loaded scalar files), so we can remove some of them:
 
\begin{verbatim}
> x$vectors <- NULL
> x$histograms <- NULL
> x$fields <- NULL
> x$bins <- NULL
> x$params <- NULL
> x$attributes <- NULL
> names(x)
[1] "runs"    "files"   "scalars"
\end{verbatim}

Individual columns of data frame components can also be selected with the \$ notation.
For example, the values of all output scalars can be displayed with \ttt{x$scalars$value}

\begin{verbatim}
> names(x$scalars)
[1] "scalar_key" "run_key"    "file_key"   "module"     "name"       "value"     
> x$scalars$value
 [1] 1.000000e+00 1.000000e+01 5.400007e+03 1.969656e-01 2.415980e+03
 [6] 8.734217e-01 3.992800e+04 1.612558e-01 8.781000e+03 1.000000e+00
[11] 1.000000e+01 5.400023e+03 1.980867e-01 2.449936e+03 1.193256e+00
[16] 4.054700e+04 1.582669e-01 8.618000e+03 2.000000e+00 1.000000e+01
[21] 5.400176e+03 1.682003e-01 9.881766e+02 6.155766e-01 1.463500e+04
[26] 1.944002e-01 1.058300e+04
\end{verbatim}

Let us store the values in a separate variable

\begin{verbatim}
> v <- x$scalars$value
> v
 [1] 1.000000e+00 1.000000e+01 5.400007e+03 1.969656e-01 2.415980e+03 8.734217e-01 3.992800e+04 1.612558e-01
 [9] 8.781000e+03 1.000000e+00 1.000000e+01 5.400023e+03 1.980867e-01 2.449936e+03 1.193256e+00 4.054700e+04
[17] 1.582669e-01 8.618000e+03 2.000000e+00 1.000000e+01 5.400176e+03 1.682003e-01 9.881766e+02 6.155766e-01
[25] 1.463500e+04 1.944002e-01 1.058300e+04
\end{verbatim}

and calculate some statistical properties:

\begin{verbatim}
> min(v)
[1] 0.1582669
> max(v)
[1] 40547
> base::sum(v)
[1] 145184.1
> length(v)
[1] 27
> base::mean(v)
[1] 5377.187
> var(v)
[1] 116749219
> sd(v)
[1] 10805.06
\end{verbatim}

Note that we had to write sum() as base::sum(). This is because the omnetpp package also defines
a sum() symbol which shadows the sum() defined in the base package, causing an error:

\begin{verbatim}
> sum(v)
Error in sum(v) : unused argument(s) (v)
\end{verbatim}

The index operator (\ttt{[]}) works as expected, except that indexing is 1-based, 
not 0-based as in C for example, and ranges are also accepted:

\begin{verbatim}
> v[3]
[1] 5400.007
> v[1:3]
[1]    1.000   10.000 5400.007
\end{verbatim}

The index operator also accepts a boolean vector that selects which elements
of the vector you want to obtain. For example, the following example selects
all elements that are larger than 100:

\begin{verbatim}
> v > 100
 [1] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE
[13] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE
[25]  TRUE FALSE  TRUE
> v[v>100]
 [1]  5400.0073  2415.9798 39928.0000  8781.0000  5400.0235  2449.9358
 [7] 40547.0000  8618.0000  5400.1756   988.1766 14635.0000 10583.0000
\end{verbatim}

This feature can be used for more complex queries as well, like selecting those
elements that are within 90\% of the maximum:

\begin{verbatim}
> v[v>=0.9*max(v)]
[1] 39928 40547
\end{verbatim}

Of course, the above queries were not very meaningful, because we lumped together
all scalar result items, i.e. mixed apples with oranges. In an effort to fix this,
let's see first what names occur in our scalar results:

\begin{verbatim}
> levels(x$scalars$name)
[1] "channelUtilization:last" "collidedFrames:last"    
[3] "collisionLength:max"     "collisionLength:mean"   
[5] "collisionLength:sum"     "duration"               
[7] "mean"                    "numHosts"               
[9] "receivedFrames:last"    
\end{verbatim}

To select scalars with a specific name (e.g. \ttt{receivedFrames:last}), you can use the
indexing operator again (note the comma before the close bracket!):

\begin{verbatim}
> receivedFrames <- x$scalars[x$scalars$name == "receivedFrames:last",]
> receivedFrames
   scalar_key run_key file_key       module                name value
9           8       0        0 Aloha.server receivedFrames:last  8781
18         17       1        1 Aloha.server receivedFrames:last  8618
27         26       2        2 Aloha.server receivedFrames:last 10583
> base::mean(receivedFrames$value)
[1] 9327.333
\end{verbatim}

You can filter by module names in the same way.

To filter by runs (e.g. by run IDs), \ttt{x\$runs} needs to be "joined" (in the SQL sense)
with \ttt{x\$scalars} using the \ttt{run\_id} column. The R function that does this
is called \ttt{merge()}, and one of its pleasant properties is that it automatically figures out
which columns to join by (it uses the column names that occur in both tables):

\begin{verbatim}
> scalars2 <- merge(x$runs, x$scalars)
> scalars
   run_key                                         runid          experiment
1        0 PureAlohaExperiment-0-20100427-16:30:15-25274 PureAlohaExperiment
2        0 PureAlohaExperiment-0-20100427-16:30:15-25274 PureAlohaExperiment
3        0 PureAlohaExperiment-0-20100427-16:30:15-25274 PureAlohaExperiment
4        0 PureAlohaExperiment-0-20100427-16:30:15-25274 PureAlohaExperiment
...
             measurement replication scalar_key file_key       module
1  $numHosts=10, $mean=1          #0          0        0            .
2  $numHosts=10, $mean=1          #0          1        0            .
3  $numHosts=10, $mean=1          #0          2        0 Aloha.server
4  $numHosts=10, $mean=1          #0          3        0 Aloha.server
...
                      name        value
1                     mean 1.000000e+00
2                 numHosts 1.000000e+01
3                 duration 5.400007e+03
4     collisionLength:mean 1.969656e-01
...
\end{verbatim}

We can check that the result has the same values as the original:

\begin{verbatim}
> length(x$scalars$value)
[1] 27
> length(scalars2$value)
[1] 27
> x$scalars$value == scalars2$value
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
\end{verbatim}

Now it is possible to filter the scalars by various run attributes, for example by
run ID:

\begin{verbatim}
> scalars2[scalars2$runid == "PureAlohaExperiment-0-20100427-16:30:15-25274" & 
scalars2$name == "receivedFrames:last",]
  run_key                                         runid          experiment
9       0 PureAlohaExperiment-0-20100427-16:30:15-25274 PureAlohaExperiment
            measurement replication scalar_key file_key       module
9 $numHosts=10, $mean=1          #0          8        0 Aloha.server
                 name value
9 receivedFrames:last  8781
\end{verbatim}


The \ttt{split()} function can also be used to split the scalars by name, module, file
or other column:

\begin{verbatim}
> sx <- split(x$scalars, x$scalars$name)
> sx
$`channelUtilization:last`
   scalar_key run_key file_key       module                    name     value
8           7       0        0 Aloha.server channelUtilization:last 0.1612558
17         16       1        1 Aloha.server channelUtilization:last 0.1582669
26         25       2        2 Aloha.server channelUtilization:last 0.1944002

$`collidedFrames:last`
   scalar_key run_key file_key       module                name value
7           6       0        0 Aloha.server collidedFrames:last 39928
16         15       1        1 Aloha.server collidedFrames:last 40547
25         24       2        2 Aloha.server collidedFrames:last 14635

...
\end{verbatim}

and now you can refer to and process the different scalars separately (note the
backticks needed to escape the colon, which would otherwise be regarded as separator):

\begin{verbatim}
> sx$`channelUtilization:last`
   scalar_key run_key file_key       module                    name     value
8           7       0        0 Aloha.server channelUtilization:last 0.1612558
17         16       1        1 Aloha.server channelUtilization:last 0.1582669
26         25       2        2 Aloha.server channelUtilization:last 0.1944002
\end{verbatim}


\section{Creating Scatter Plots}

TODO


\section{Plotting Vectors}

Let us begin with loading a vector file:

\begin{verbatim}
> x <-loadDataset("OneFifo*.vec")
Loaded OneFifo-0.vec
> x$vectors
   vector_key run_key file_key vectorid            module                          name
1           0       0        0        9 SimpleQueue.queue                 queueing time
2           1       0        0        8 SimpleQueue.queue                        length
3           2       0        0        0  SimpleQueue.sink                total lifetime
4           3       0        0        1  SimpleQueue.sink           total queueing time
5           4       0        0        2  SimpleQueue.sink number of queue nodes visited
6           5       0        0        3  SimpleQueue.sink            total service time
7           6       0        0        4  SimpleQueue.sink                   total delay
8           7       0        0        5  SimpleQueue.sink number of delay nodes visited
9           8       0        0        6  SimpleQueue.sink                    generation
10          9       0        0        7 SimpleQueue.queue                  dropped jobs
\end{verbatim}

This call actually does not load the data from the vector, only the vector declarations. 
Vector data can be read with different commands.

\begin{verbatim}
> v <- loadVectors(x)
\end{verbatim}

If you get the error \ttt{indexed vector file reader: index file is not up to date}, then
you can use the \ttt{scavetool} program, part of OMNeT++, to index the file: 

\begin{verbatim}
$ scavetool index OneFifo-0.vec
\end{verbatim}

The \ttt{loadVectors} command created a data frame that contains vector data as well:

\begin{verbatim}
> names(v)
[1] "vectors"    "vectordata" "attributes"
> v
$vectors
   vector_key        ospath vectorid            module            name
1           0 OneFifo-0.vec        9 SimpleQueue.queue   queueing time
2           1 OneFifo-0.vec        8 SimpleQueue.queue          length
3           2 OneFifo-0.vec        0  SimpleQueue.sink  total lifetime
...

$vectordata
   vector_key eventno         x          y
1           0       2  1.199993  0.0000000
2           0       5  2.540825  0.2951858
3           0      15  4.565747  1.9815322
4           0      19  6.454965  3.5643205
5           0      25 10.279441  6.1744295
6           0      27 10.737616  6.3010893
7           0      49 22.216625 16.0624257
8           0      51 22.525892 15.4974533
9           0      53 23.242022 14.5606246
10          1       2  1.199993  0.0000000
11          1       4  2.245639  1.0000000
12          1       5  2.540825  0.0000000

$attributes
[1] vector_key name       value     
\end{verbatim}

The \ttt{vectordata} component contains data from all vectors;
you can use the \ttt{split()} function to split it to separate vectors:

\begin{verbatim}
> split(v$vectordata, v$vectordata$vector_key)
$`0`
  vector_key eventno         x          y
1          0       2  1.199993  0.0000000
2          0       5  2.540825  0.2951858
3          0      15  4.565747  1.9815322
4          0      19  6.454965  3.5643205
...

$`1`
   vector_key eventno         x y
10          1       2  1.199993 0
11          1       4  2.245639 1
12          1       5  2.540825 0
13          1       8  2.584215 1
...
...

$`9`
   vector_key eventno        x y
86          9      34 13.77896 1
87          9      36 15.69610 2
88          9      38 17.17379 3
89          9      40 17.64087 4
\end{verbatim}

To create a chart from all vectors:

\begin{verbatim}
> plotLineChart(split(v$vectordata, v$vectordata$vector_key), list(X.Axis.Title='t', Y.Axis.Title='data'))
\end{verbatim}


This concludes our short tutorial.
